<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Sticker Booth (Auto Cloud Sync)</title>
    <!-- AI & AR Engines -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; background-color: #000; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; overflow: hidden; height: 100vh; color: white; }
        
        #scene-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            perspective: 800px; 
            transform: translateZ(0);
        }

        canvas { 
            position: absolute; 
            left: 0; top: 0; 
            width: 100%; height: 100%; 
            object-fit: cover; 
        }

        #sticker-layer {
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transform-style: preserve-3d;
        }

        .sticker {
            position: absolute;
            top: 0; left: 0;
            transform-style: preserve-3d;
            will-change: transform;
            transform-origin: 0 0; 
            backface-visibility: hidden;
        }

        /* --- UI LAYERS --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        #shutter-btn {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 80px; height: 80px;
            background: white; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.3);
            background-clip: padding-box;
            cursor: pointer; pointer-events: auto;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #shutter-btn:active { transform: translateX(-50%) scale(0.9); background: #ddd; }

        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 150px; font-weight: 800; color: white;
            text-shadow: 0 4px 30px rgba(0,0,0,0.5);
            display: none; z-index: 60;
            font-variant-numeric: tabular-nums;
        }

        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 70;
            transition: opacity 0.1s ease-out;
        }

        #result-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 80;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(10px);
        }
        #result-img {
            max-width: 90%; max-height: 60%;
            border-radius: 16px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            border: 2px solid #333;
        }
        .modal-btns { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; width: 90%; }
        .btn-action {
            padding: 14px 24px; border-radius: 12px; border: none;
            font-size: 16px; font-weight: 600; cursor: pointer;
            color: white; transition: transform 0.1s;
            display: flex; align-items: center; gap: 8px;
        }
        .btn-action:active { transform: scale(0.95); }
        .btn-save { background: #007AFF; color: white; box-shadow: 0 4px 15px rgba(0, 122, 255, 0.4); }
        .btn-retake { background: transparent; color: #aaa; border: 1px solid #444; }

        /* Cloud Status Indicator */
        #cloud-status {
            margin-top: 15px;
            font-size: 13px;
            color: #888;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .status-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background-color: #444;
        }
        .status-dot.uploading { background-color: #FFD700; box-shadow: 0 0 8px #FFD700; }
        .status-dot.done { background-color: #00ff88; box-shadow: 0 0 8px #00ff88; }
        .status-dot.error { background-color: #ff4444; }

        /* Controls (Debug) - Compact */
        #controls {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 12px;
            pointer-events: auto; min-width: 250px;
            transition: all 0.3s ease;
            max-height: 60vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #controls.minimized { width: auto; min-width: 0; padding: 8px; height: auto; overflow: hidden; }
        #controls.minimized .control-content { display: none; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .control-row { display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center; }
        input[type=range] { width: 100px; accent-color: #00ff88; }
        label { font-size: 11px; color: #ccc; font-weight: 500; }
        button { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        button.active { background: #00ff88; color: black; border-color: #00ff88; }
        button.icon-btn { padding: 4px 10px; font-weight: bold; }
        .part-nav { display: flex; gap: 5px; align-items: center; }
        
        #loading { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: rgba(0,0,0,0.8); padding: 24px; border-radius: 20px; 
            text-align: center; max-width: 80%;
            backdrop-filter: blur(5px);
        }
        .spinner {
            width: 30px; height: 30px; border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid #00ff88; 
            border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="scene-container">
        <video id="input_video" style="display:none" playsinline muted></video>
        <canvas id="output_canvas"></canvas>
        <div id="sticker-layer"></div>
    </div>
    
    <div id="flash"></div>
    <div id="countdown">3</div>

    <div id="ui-layer">
        <div id="loading">
            <div class="spinner"></div>
            <div id="loading-text">Loading Camera...</div>
        </div>
        
        <button id="shutter-btn" onclick="startCountdown()"></button>

        <div id="controls">
            <div class="control-header">
                <span style="font-weight:bold; color:#00ff88; font-size:14px;">Designer Mode</span>
                <div style="display:flex; gap:5px;">
                    <button id="btn-debug" onclick="toggleDebug()">Debug</button>
                    <button class="icon-btn" onclick="toggleUI()" id="btn-min">_</button>
                </div>
            </div>
            <div class="control-content">
                <hr style="border-color: rgba(255,255,255,0.1); margin: 5px 0 10px 0;">
                <div id="prop-controls" style="opacity: 0.5; pointer-events: none;">
                    <div class="control-row">
                        <div style="font-size: 11px; color:#fff"><span id="edit-name">None</span></div>
                        <div class="part-nav" id="part-nav" style="display:none">
                            <button onclick="changePart(-1)">&lt;</button>
                            <span id="part-label" style="font-size:10px">1/1</span>
                            <button onclick="changePart(1)">&gt;</button>
                        </div>
                    </div>
                    <div class="control-row"><label>Scale <span id="val-scale">1.0</span></label><input type="range" min="0.1" max="5.0" step="0.1" id="in-scale" oninput="updateProp('scale', this.value)"></div>
                    <!-- INCREASED RANGES HERE (-1000 to 1000) -->
                    <div class="control-row"><label>Off X <span id="val-offsetX">0</span></label><input type="range" min="-1000" max="1000" step="5" id="in-offsetX" oninput="updateProp('offsetX', this.value)"></div>
                    <div class="control-row"><label>Off Y <span id="val-offsetY">0</span></label><input type="range" min="-1000" max="1000" step="5" id="in-offsetY" oninput="updateProp('offsetY', this.value)"></div>
                    <div class="control-row"><label>Off Z <span id="val-offsetZ">0</span></label><input type="range" min="-200" max="200" step="5" id="in-offsetZ" oninput="updateProp('offsetZ', this.value)"></div>
                    <hr style="border-color: rgba(255,255,255,0.1); margin: 8px 0;">
                    <div class="control-row"><label>Pitch <span id="val-rotationX">0</span>°</label><input type="range" min="-180" max="180" step="5" id="in-rotationX" oninput="updateProp('rotationX', this.value)"></div>
                    <div class="control-row"><label>Yaw <span id="val-rotationY">0</span>°</label><input type="range" min="-180" max="180" step="5" id="in-rotationY" oninput="updateProp('rotationY', this.value)"></div>
                    <div class="control-row"><label>Roll <span id="val-rotation">0</span>°</label><input type="range" min="-180" max="180" step="5" id="in-rotation" oninput="updateProp('rotation', this.value)"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Result Modal -->
    <div id="result-modal">
        <img id="result-img" src="" alt="Captured Photo">
        
        <div class="modal-btns" id="action-buttons">
            <a id="download-link" download="photobooth_snap.jpg">
                <button class="btn-action btn-save">Download ⬇️</button>
            </a>
            <button class="btn-action btn-retake" onclick="closeModal()">Retake</button>
        </div>

        <div id="cloud-status">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">Ready</span>
        </div>
    </div>

    <script>
        // --- CLOUDINARY CONFIGURATION ---
        // 1. Sign up at cloudinary.com (Free)
        // 2. Settings -> Upload -> Add Upload Preset -> Signing Mode: "Unsigned"
        
        const CLOUDINARY_CONFIG = {
            cloudName: "dh85g5yyh", 
            uploadPreset: "fitzmas-photobooth" 
        };

        // AUTO-UPLOAD Function (No SDK needed, just standard Fetch)
        window.autoUploadToCloud = async function(blob) {
            const statusDot = document.getElementById('status-dot');
            const statusText = document.getElementById('status-text');

            // UI State: Uploading
            statusText.innerText = "Backing up...";
            statusDot.className = "status-dot uploading";

            try {
                // 1. Prepare Data
                const formData = new FormData();
                formData.append('file', blob);
                formData.append('upload_preset', CLOUDINARY_CONFIG.uploadPreset);
                // Optional: Add tags to find them easily later
                formData.append('tags', 'fitzmas_party'); 

                // 2. Send to Cloudinary API
                const url = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CONFIG.cloudName}/image/upload`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                // 3. Success
                statusText.innerText = "Backed up ✔️";
                statusDot.className = "status-dot done";
                console.log("Uploaded!", data.secure_url);

            } catch (err) {
                console.error("Upload Error:", err);
                statusText.innerText = "Backup Failed";
                statusDot.className = "status-dot error";
            }
        };
    </script>

    <script>
        // --- CONFIGURATION ---
        const SMOOTHING = 0.2; 
        const REFERENCE_FACE_WIDTH = 300; // Pivot point for offset scaling (Standard Selfie Distance)

        // Current Filter Set
        const FILTERS = [
            {
                id: 'marnix', 
                parts: [
                    // BEARD: Adjusted settings
                    { type: 'image', id: 'bandit_beard', src: 'https://i.imgur.com/1vVKJ91.png', anchorIndex: 152, scale: 1.2, offsetX: 0, offsetY: -150, offsetZ: 5, rotation: 0, rotationX: -20, rotationY: 0, zIndex: 100 },
                    // SCARF (Bandana)
                    { type: 'image', id: 'bandana', src: 'https://i.imgur.com/7mkFOI4.png', anchorIndex: 152, scale: 1.3, offsetX: 0, offsetY: 80, offsetZ: -100, rotation: 0, rotationX: -20, rotationY: 0, zIndex: 90 },
                    // HAT (Cap)
                    { type: 'image', id: 'cap', src: 'https://i.imgur.com/E7Loive.png', anchorIndex: 10, scale: 1.4, offsetX: 0, offsetY: -15, offsetZ: 30, rotation: 0, rotationX: 0, rotationY: 0, zIndex: 200 }
                ]
            },
            {
                id: 'alex',
                parts: [
                    // GLASSES: Tuned settings
                    { type: 'image', id: 'alex_glasses', src: 'https://i.imgur.com/r6svhAm.png', anchorIndex: 168, scale: 1.1, offsetX: 0, offsetY: 35, offsetZ: 20, rotation: 0, rotationX: -15, rotationY: 0, zIndex: 200 },
                    // OLIVE OIL: Tuned settings
                    { type: 'image', id: 'alex_oil', src: 'https://i.imgur.com/QYEBVU1.png', anchorIndex: 454, scale: 1.8, offsetX: 390, offsetY: -365, offsetZ: 200, rotation: 10, rotationX: -15, rotationY: 0, zIndex: 100 }
                ]
            },
            {
                id: 'floortje',
                parts: [
                    // WIG: Tuned settings
                    { type: 'image', id: 'floortje_wig', src: 'https://i.imgur.com/it2jrUM.png', anchorIndex: 10, scale: 1.9, offsetX: 0, offsetY: 190, offsetZ: -15, rotation: 0, rotationX: -10, rotationY: 0, zIndex: 200 },
                    // NECKLACE: Tuned settings
                    { type: 'image', id: 'floortje_necklace', src: 'https://i.imgur.com/lS9mKOb.png', anchorIndex: 152, scale: 1.0, offsetX: 0, offsetY: 155, offsetZ: -125, rotation: 0, rotationX: 0, rotationY: 0, zIndex: 90 }
                ]
            },
            {
                id: 'raf',
                parts: [
                    { type: 'image', id: 'raf_mask', src: 'https://i.imgur.com/dFJxaVq.png', anchorIndex: 168, scale: 2.8, offsetX: 0, offsetY: 10, offsetZ: 30, rotation: 0, rotationX: -10, rotationY: 0, zIndex: 150 }
                ]
            },
            {
                id: 'mischa',
                parts: [
                    { type: 'image', id: 'mischa_sweater', src: 'https://i.imgur.com/jpKunad.png', anchorIndex: 152, scale: 3.0, offsetX: 0, offsetY: 520, offsetZ: 0, rotation: 0, rotationX: 0, rotationY: 0, zIndex: 50 }
                ]
            },
            {
                id: 'derk',
                parts: [
                    // BALD CAP: Tuned settings
                    { type: 'image', id: 'derk_head', src: 'https://i.imgur.com/3rAuZew.png', anchorIndex: 10, scale: 1.1, offsetX: 0, offsetY: 45, offsetZ: 20, rotation: 0, rotationX: -10, rotationY: 0, zIndex: 200 }
                ]
            },
            {
                id: 'jur',
                parts: [
                    // JUR BODY: Tuned settings
                    { type: 'image', id: 'jur_tall', src: 'https://i.imgur.com/4Vs89Aj.png', anchorIndex: 1, scale: 4.5, offsetX: 0, offsetY: 50, offsetZ: 50, rotation: 0, rotationX: -15, rotationY: 0, zIndex: 200 }
                ]
            }
        ];

        // --- STATE ---
        let debugMode = false;
        let selectedFaceIndex = -1; 
        let selectedPartIndex = 0; 
        let faceAssignments = new Map();
        let detectedFaces = [];
        let faceStates = []; 
        let loadedImages = {};
        let activeFaceData = []; 

        // --- ELEMENTS ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const stickerLayer = document.getElementById('sticker-layer');
        const ctx = canvasElement.getContext('2d');
        const loadingDiv = document.getElementById('loading');
        const loadingText = document.getElementById('loading-text');

        // --- VECTOR MATH ---
        const f = (n) => n.toFixed(4);
        function subtract(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z }; }
        function cross(a, b) { return { x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x }; }
        function normalize(v) {
            const mag = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z) || 1;
            return { x: v.x/mag, y: v.y/mag, z: v.z/mag };
        }
        function getMirroredPoint(landmark, width, height) {
            return {
                x: (1 - landmark.x) * width, 
                y: landmark.y * height,
                z: -landmark.z * width 
            };
        }
        function calculateFaceMatrix(landmarks, width, height) {
            const eyeL = getMirroredPoint(landmarks[33], width, height); 
            const eyeR = getMirroredPoint(landmarks[263], width, height); 
            const mouth = getMirroredPoint(landmarks[13], width, height); 
            
            const vecX = normalize(subtract(eyeL, eyeR));
            const midEye = { x: (eyeL.x + eyeR.x)/2, y: (eyeL.y + eyeR.y)/2, z: (eyeL.z + eyeR.z)/2 };
            const vecY_temp = normalize(subtract(mouth, midEye));
            const vecZ = normalize(cross(vecX, vecY_temp));
            const vecY = normalize(cross(vecZ, vecX));

            return { x: vecX, y: vecY, z: vecZ };
        }
        function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
        function lerpVector(v1, v2, amt) {
            return { x: lerp(v1.x, v2.x, amt), y: lerp(v1.y, v2.y, amt), z: lerp(v1.z, v2.z, amt) };
        }

        // --- RENDERING ---
        function getStickerElement(faceId, partId, src, type, zIndex) {
            const id = `sticker-${faceId}-${partId}`;
            let el = document.getElementById(id);
            if (!el) {
                if (type === 'image') {
                    el = document.createElement('img');
                    el.src = src;
                } else {
                    el = document.createElement('div');
                    el.innerText = src;
                    el.style.fontSize = "50px";
                }
                el.id = id;
                el.className = 'sticker';
                el.style.zIndex = zIndex; 
                stickerLayer.appendChild(el);
            }
            if (type === 'image' && el.src !== src) el.src = src;
            return el;
        }

        function onResults(results) {
            loadingDiv.style.display = 'none';
            
            const dpr = window.devicePixelRatio || 1;
            canvasElement.width = window.innerWidth * dpr;
            canvasElement.height = window.innerHeight * dpr;

            ctx.save();
            ctx.translate(canvasElement.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            ctx.restore();

            detectedFaces = [];
            const currentStickerIds = new Set();
            activeFaceData = [];

            if (results.multiFaceLandmarks) {
                const sorted = results.multiFaceLandmarks.map((l, i) => ({ l, i, x: l[1].x })).sort((a,b) => a.x - b.x);

                if (sorted.length !== faceStates.length) faceStates = new Array(sorted.length).fill(null);

                sorted.forEach((face, idx) => {
                    const landmarks = face.l;
                    if (!faceAssignments.has(idx)) faceAssignments.set(idx, idx % FILTERS.length);
                    const filterIndex = faceAssignments.get(idx);
                    const filter = FILTERS[filterIndex];

                    // Calculations based on High-DPI canvas size
                    const targetWidth = Math.abs(landmarks[454].x - landmarks[234].x) * canvasElement.width; 
                    const matrixBasis = calculateFaceMatrix(landmarks, canvasElement.width, canvasElement.height);
                    
                    if (!faceStates[idx]) {
                        faceStates[idx] = { w: targetWidth, basis: matrixBasis, anchors: {} };
                    }

                    const state = faceStates[idx];
                    state.w = lerp(state.w, targetWidth, SMOOTHING);
                    state.basis.x = lerpVector(state.basis.x, matrixBasis.x, SMOOTHING);
                    state.basis.y = lerpVector(state.basis.y, matrixBasis.y, SMOOTHING);
                    state.basis.z = lerpVector(state.basis.z, matrixBasis.z, SMOOTHING);

                    const faceSnapshotParts = [];

                    filter.parts.forEach((part, partIdx) => {
                        const el = getStickerElement(idx, part.id, part.src || part.content, part.type, part.zIndex);
                        currentStickerIds.add(el.id);

                        const isSelected = (debugMode && selectedFaceIndex === idx && selectedPartIndex === partIdx);
                        const rawAnchor = getMirroredPoint(landmarks[part.anchorIndex], canvasElement.width, canvasElement.height);

                        if (!state.anchors[part.anchorIndex]) state.anchors[part.anchorIndex] = rawAnchor;
                        const smoothAnchor = state.anchors[part.anchorIndex];
                        smoothAnchor.x = lerp(smoothAnchor.x, rawAnchor.x, SMOOTHING);
                        smoothAnchor.y = lerp(smoothAnchor.y, rawAnchor.y, SMOOTHING);
                        smoothAnchor.z = lerp(smoothAnchor.z, rawAnchor.z, SMOOTHING);

                        const X = state.basis.x;
                        const Y = state.basis.y;
                        const Z = state.basis.z;
                        
                        const rotationMatrix = `matrix3d(
                            ${f(X.x)}, ${f(X.y)}, ${f(X.z)}, 0,
                            ${f(Y.x)}, ${f(Y.y)}, ${f(Y.z)}, 0,
                            ${f(Z.x)}, ${f(Z.y)}, ${f(Z.z)}, 0,
                            0, 0, 0, 1
                        )`;

                        const cssScale = 1 / dpr; 
                        
                        // DYNAMIC DEPTH SCALING
                        // Calculate ratio of Current Face Width vs Standard Face Width (300px logic)
                        // state.w is physical pixels, so we divide by dpr to get logical pixels for comparison
                        const logicalFaceWidth = state.w / dpr;
                        const depthScale = logicalFaceWidth / REFERENCE_FACE_WIDTH;

                        // Apply Depth Scale to Offsets
                        const offX = (part.offsetX || 0) * dpr * depthScale;
                        const offY = (part.offsetY || 0) * dpr * depthScale;
                        const offZ = (part.offsetZ || 20) * dpr * depthScale;
                        
                        const rotX = part.rotationX || 0;
                        const rotY = part.rotationY || 0;
                        const rotZ = part.rotation || 0; 

                        el.style.transform = `
                            translate3d(${f(smoothAnchor.x * cssScale)}px, ${f(smoothAnchor.y * cssScale)}px, ${f(smoothAnchor.z * cssScale)}px)
                            ${rotationMatrix}
                            translateZ(${offZ * cssScale}px)
                            rotateX(${rotX}deg)
                            rotateY(${rotY}deg)
                            rotateZ(${rotZ}deg)
                            translate(${offX * cssScale}px, ${offY * cssScale}px)
                            translate(-50%, -50%)
                        `;
                        
                        const size = state.w * part.scale; 
                        el.style.width = `${size * cssScale}px`; 
                        el.style.height = "auto"; 
                        el.style.filter = isSelected ? "drop-shadow(0 0 10px #00ff88) brightness(1.2)" : "none";
                        el.style.display = 'block';

                        const simpleRoll = Math.atan2(X.y, X.x) + (rotZ * Math.PI/180);
                        faceSnapshotParts.push({
                            id: part.id, 
                            src: part.src || part.content,
                            type: part.type,
                            x: smoothAnchor.x + offX, 
                            y: smoothAnchor.y + offY,
                            scale: size,
                            rotation: simpleRoll,
                            zIndex: part.zIndex
                        });
                    });

                    activeFaceData.push(faceSnapshotParts);

                    if (debugMode) drawDebugMarkers(ctx, landmarks);
                    detectedFaces.push({ id: idx, box: getBoundingBox(landmarks), filterIndex });
                });

                const allStickers = document.querySelectorAll('.sticker');
                allStickers.forEach(el => {
                    if (!currentStickerIds.has(el.id)) el.style.display = 'none';
                });
            }
        }

        // --- SNAPSHOT LOGIC ---
        
        function startCountdown() {
            document.getElementById('shutter-btn').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            const countEl = document.getElementById('countdown');
            countEl.style.display = 'block';
            
            let count = 3;
            countEl.innerText = count;
            
            const timer = setInterval(() => {
                count--;
                if (count > 0) {
                    countEl.innerText = count;
                } else {
                    clearInterval(timer);
                    countEl.style.display = 'none';
                    triggerFlash();
                    takeSnapshot();
                }
            }, 1000);
        }

        function triggerFlash() {
            const flash = document.getElementById('flash');
            flash.style.opacity = 1;
            setTimeout(() => { flash.style.opacity = 0; }, 100);
        }

        function takeSnapshot() {
            const snapCanvas = document.createElement('canvas');
            snapCanvas.width = canvasElement.width;
            snapCanvas.height = canvasElement.height;
            const snapCtx = snapCanvas.getContext('2d');

            snapCtx.drawImage(canvasElement, 0, 0);

            let allParts = [];
            activeFaceData.forEach(parts => { allParts = allParts.concat(parts); });
            allParts.sort((a, b) => a.zIndex - b.zIndex);

            allParts.forEach(part => {
                if (part.type === 'image') {
                    const img = loadedImages[part.id];
                    if (img && img.complete) {
                        snapCtx.save();
                        snapCtx.translate(part.x, part.y);
                        snapCtx.rotate(part.rotation);
                        const aspect = img.height / img.width;
                        const drawW = part.scale;
                        const drawH = part.scale * aspect;
                        snapCtx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                        snapCtx.restore();
                    }
                }
            });

            const dataURL = snapCanvas.toDataURL('image/jpeg', 0.9);
            const imgEl = document.getElementById('result-img');
            imgEl.src = dataURL;
            
            document.getElementById('download-link').href = dataURL;
            document.getElementById('result-modal').style.display = 'flex';
            
            // AUTO UPLOAD
            const statusText = document.getElementById('status-text');
            const statusDot = document.getElementById('status-dot');
            statusText.innerText = "Processing...";
            statusDot.className = "status-dot";

            fetch(dataURL)
                .then(res => res.blob())
                .then(blob => {
                    if (window.autoUploadToCloud) window.autoUploadToCloud(blob);
                });
        }

        function closeModal() {
            document.getElementById('result-modal').style.display = 'none';
            document.getElementById('shutter-btn').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
        }

        // --- UTILS ---
        function getBoundingBox(landmarks) {
            let minX=1, minY=1, maxX=0, maxY=0;
            landmarks.forEach(p => { 
                if(p.x < minX) minX=p.x; if(p.x > maxX) maxX=p.x;
                if(p.y < minY) minY=p.y; if(p.y > maxY) maxY=p.y;
            });
            return {minX, minY, maxX, maxY};
        }

        function drawDebugMarkers(ctx, landmarks) {
            const anchors = [{id: 10, color: 'red'}, {id: 168, color: '#0f0'}, {id: 1, color: 'orange'}, {id: 152, color: 'cyan'}];
            ctx.save();
            ctx.translate(canvasElement.width, 0); ctx.scale(-1, 1); 
            anchors.forEach(a => {
                const pt = landmarks[a.id];
                const x = pt.x * canvasElement.width;
                const y = pt.y * canvasElement.height;
                ctx.beginPath(); ctx.arc(x, y, 4 * window.devicePixelRatio, 0, 2*Math.PI); ctx.fillStyle = a.color; ctx.fill();
            });
            ctx.restore();
        }

        document.addEventListener('click', (e) => {
            if (e.target.closest('#controls') || e.target.closest('#shutter-btn') || e.target.closest('#result-modal')) return;
            const rect = canvasElement.getBoundingClientRect();
            const normX = 1 - ((e.clientX - rect.left) / rect.width);
            const normY = (e.clientY - rect.top) / rect.height;
            detectedFaces.forEach(face => {
                const b = face.box;
                if (normX >= b.minX && normX <= b.maxX && normY >= b.minY && normY <= b.maxY) {
                    if (debugMode) activateControls(face.id);
                    else {
                        const next = (face.filterIndex + 1) % FILTERS.length;
                        faceAssignments.set(face.id, next);
                    }
                }
            });
        });

        // --- UI LOGIC ---
        function toggleUI() {
            const c = document.getElementById('controls');
            const btn = document.getElementById('btn-min');
            c.classList.toggle('minimized');
            btn.innerText = c.classList.contains('minimized') ? '+' : '_';
        }

        function toggleDebug() {
            debugMode = !debugMode;
            const btn = document.getElementById('btn-debug');
            btn.innerText = debugMode ? "Debug: ON" : "Debug: OFF";
            btn.classList.toggle('active', debugMode);
            if(!debugMode) { selectedFaceIndex=-1; document.getElementById('prop-controls').style.opacity='0.5'; document.getElementById('prop-controls').style.pointerEvents='none'; }
        }
        
        function updateProp(key, val) {
            if (selectedFaceIndex === -1) return;
            const f = FILTERS[faceAssignments.get(selectedFaceIndex)];
            const p = f.parts[selectedPartIndex];
            p[key] = parseFloat(val);
            if(document.getElementById(`val-${key}`)) document.getElementById(`val-${key}`).innerText=val;
            console.log(`Updated ${f.id} Part ${selectedPartIndex}:`, p);
        }
        
        function changePart(dir) {
            if (selectedFaceIndex === -1) return;
            const f = FILTERS[faceAssignments.get(selectedFaceIndex)];
            let n = selectedPartIndex + dir;
            if(n<0) n=f.parts.length-1; if(n>=f.parts.length) n=0;
            selectedPartIndex=n; refreshControlsUI();
        }
        
        function refreshControlsUI() {
            const f = FILTERS[faceAssignments.get(selectedFaceIndex)];
            const p = f.parts[selectedPartIndex];
            document.getElementById('edit-name').innerText = `${f.id.toUpperCase()} (${p.id})`;
            const nav = document.getElementById('part-nav');
            if(f.parts.length>1){ nav.style.display='flex'; document.getElementById('part-label').innerText=`${selectedPartIndex+1}/${f.parts.length}`; } else nav.style.display='none';
            
            const set = (k, def) => {
                const val = p[k] !== undefined ? p[k] : def;
                document.getElementById(`in-${k}`).value = val;
                document.getElementById(`val-${k}`).innerText = val;
            };
            set('scale', 1.0); set('offsetX', 0); set('offsetY', 0); set('offsetZ', 20);
            set('rotation', 0); set('rotationX', 0); set('rotationY', 0);
        }
        
        function activateControls(idx) { selectedFaceIndex=idx; selectedPartIndex=0; document.getElementById('prop-controls').style.opacity='1'; document.getElementById('prop-controls').style.pointerEvents='auto'; refreshControlsUI(); }

        // --- ASSET LOADER ---
        function loadAssets() {
            const promises = [];
            FILTERS.forEach(filter => {
                filter.parts.forEach(part => {
                    if (part.type === 'image') {
                        const img = new Image();
                        img.crossOrigin = "Anonymous"; 
                        img.src = part.src;
                        const p = new Promise(resolve => {
                            img.onload = () => { loadedImages[part.id] = img; resolve(); };
                            img.onerror = () => { console.warn("Asset failed:", part.id); resolve(); };
                            setTimeout(() => resolve(), 3000); 
                        });
                        promises.push(p);
                    }
                });
            });
            return Promise.all(promises);
        }

        async function startApp() {
            try {
                if (typeof FaceMesh === 'undefined' || typeof Camera === 'undefined') throw new Error("MediaPipe failed to load.");
                const faceMesh = new FaceMesh({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces: 4, refineLandmarks: true, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
                faceMesh.onResults(onResults);
                await loadAssets();
                loadingText.innerText = "Requesting Camera...";
                
                const cam = new Camera(videoElement, {
                    onFrame: async()=>{ await faceMesh.send({image:videoElement}); }, 
                    width: 1280, 
                    height: 720 
                });
                
                await cam.start();
                loadingText.innerText = "Waiting for face...";
            } catch (err) {
                console.error(err);
                loadingDiv.style.backgroundColor = 'rgba(255, 50, 50, 0.9)';
                loadingDiv.innerHTML = `<strong>Error:</strong><br>${err.message}`;
            }
        }

        startApp();
    </script>
</body>
</html>
