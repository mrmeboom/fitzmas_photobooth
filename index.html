<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>FitzMas Photobooth</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fleur+De+Leah&family=Henny+Penny&display=swap" rel="stylesheet">

    <!-- AI & AR Engines -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            --velvet-base: #4a0404;
            --velvet-highlight: #750b0b;
            --velvet-shadow: #210000;
            --gold-light: #fbe68b;
            --gold-mid: #d4af37;
            --gold-dark: #8a6e1e;
        }

        body { 
            margin: 0; 
            background-color: #000; 
            font-family: "Henny Penny", system-ui; 
            overflow: hidden; 
            height: 100vh; 
            color: white; 
        }
        
        /* --- BACKGROUND LAYERS (WebGL) --- */
        #glCanvas, #snowCanvas, #burstCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #glCanvas { z-index: 0; }
        #snowCanvas { z-index: 1; pointer-events: none; }
        #burstCanvas { z-index: 85; pointer-events: none; } /* Burst is high up */

        /* --- LANDING PAGE --- */
        #landing-page {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, var(--velvet-highlight), var(--velvet-base) 60%, var(--velvet-shadow));
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease;
        }

        /* --- TYPOGRAPHY --- */
        .gold-text {
            background: linear-gradient(to bottom, var(--gold-light) 0%, var(--gold-mid) 50%, var(--gold-dark) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            filter: drop-shadow(0px 2px 0px rgba(0,0,0,0.5));
        }

        .title-fitzmas {
            font-family: "Fleur De Leah", cursive;
            font-size: 5rem;
            transform: rotate(-2deg);
            line-height: 1.2;
            display: block;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .title-sub {
            font-family: "Henny Penny", system-ui;
            font-size: 2.2rem;
            letter-spacing: 1px;
            display: block;
            text-align: center;
        }

        /* White text version for main camera view */
        .white-text {
            color: white;
            text-shadow: 0 4px 10px rgba(0,0,0,0.8);
        }

        /* --- BUTTONS (GOLD STYLE) --- */
        .btn-gold {
            font-family: "Henny Penny", system-ui;
            font-size: 1.8rem;
            text-transform: capitalize; 
            letter-spacing: 1px;
            color: #3e2704; /* Dark gold/brown text */
            background: linear-gradient(180deg, var(--gold-light) 0%, var(--gold-mid) 40%, var(--gold-dark) 100%);
            border: none;
            padding: 15px 40px;
            border-radius: 12px;
            cursor: pointer;
            box-shadow: 
                inset 1px 1px 0px rgba(255,255,255,0.4),
                inset -1px -1px 0px rgba(0,0,0,0.2),
                0px 5px 10px rgba(0,0,0,0.5);
            transition: transform 0.1s;
            text-decoration: none; /* For the link */
            display: inline-block;
        }
        .btn-gold:active { transform: translateY(2px); }

        .btn-gold-outline {
            font-family: "Henny Penny", system-ui;
            font-size: 1.8rem;
            text-transform: capitalize;
            color: var(--gold-mid);
            background: transparent;
            border: 3px solid var(--gold-mid);
            padding: 12px 30px;
            border-radius: 12px;
            cursor: pointer;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .btn-gold-outline:active { transform: translateY(2px); color: var(--gold-light); border-color: var(--gold-light); }

        /* --- MAIN APP UI --- */
        #app-container {
            display: none; /* Hidden until start */
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }

        #scene-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            /* Background transparent so WebGL shows through when video is hidden */
            background: transparent; 
            perspective: 800px; 
            transform: translateZ(0);
        }

        canvas#output_canvas { 
            position: absolute; 
            left: 0; top: 0; 
            width: 100%; height: 100%; 
            object-fit: cover; 
        }

        #sticker-layer {
            position: absolute;
            left: 0; top: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transform-style: preserve-3d;
        }

        .sticker {
            position: absolute;
            top: 0; left: 0;
            transform-style: preserve-3d;
            will-change: transform;
            transform-origin: 0 0; 
            backface-visibility: hidden;
        }

        #app-title-overlay {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 40;
            pointer-events: none;
        }

        /* Shutter */
        #shutter-btn {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 80px; height: 80px;
            background: white; border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.3);
            background-clip: padding-box;
            cursor: pointer; pointer-events: auto;
            z-index: 50;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s;
        }
        #shutter-btn:active { transform: translateX(-50%) scale(0.9); background: #ddd; }

        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 150px; font-weight: 800; color: white;
            text-shadow: 0 4px 30px rgba(0,0,0,0.5);
            display: none; z-index: 60;
            font-variant-numeric: tabular-nums;
            font-family: system-ui; /* Clear font for numbers */
        }

        #flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 70;
            transition: opacity 0.1s ease-out;
        }

        /* Result Modal */
        #result-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            /* Transparent to show WebGL background */
            background: transparent;
            z-index: 80;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
            backdrop-filter: blur(0px); /* Removed blur to keep BG sharp */
        }
        #result-img {
            max-width: 90%; max-height: 55%;
            border-radius: 16px; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            margin-bottom: 30px;
            border: 4px solid var(--gold-mid);
        }
        .modal-btns { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; width: 100%; }

        /* Secret Debug Hotspot */
        #debug-hotspot {
            position: absolute; top: 0; left: 0; width: 60px; height: 60px;
            z-index: 100; pointer-events: auto;
        }

        /* Controls (Debug) - Hidden Default */
        #controls {
            display: none;
            position: absolute; top: 60px; left: 20px;
            background: rgba(0,0,0,0.6); padding: 15px; border-radius: 12px;
            pointer-events: auto; min-width: 250px; z-index: 101;
            max-height: 60vh; overflow-y: auto;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);
        }
        #controls.minimized { width: auto; min-width: 0; padding: 8px; height: auto; overflow: hidden; }
        #controls.minimized .control-content { display: none; }
        .control-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .control-row { display: flex; justify-content: space-between; margin-bottom: 8px; align-items: center; }
        input[type=range] { width: 100px; accent-color: #00ff88; }
        label { font-size: 11px; color: #ccc; font-weight: 500; font-family: system-ui; }
        button.debug-btn { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
        .part-nav { display: flex; gap: 5px; align-items: center; }

        @media (max-width: 600px) {
            .title-fitzmas { font-size: 3.5rem; }
            .title-sub { font-size: 1.6rem; }
            .btn-gold, .btn-gold-outline { font-size: 1.4rem; padding: 12px 25px; }
        }
    </style>
</head>
<body>

    <!-- 1. BACKGROUND LAYERS (Karaokatron Style) -->
    <canvas id="glCanvas"></canvas>
    <canvas id="snowCanvas"></canvas>
    <canvas id="burstCanvas"></canvas>

    <!-- 2. LANDING PAGE -->
    <div id="landing-page">
        <div style="text-align: center; margin-bottom: 40px;">
            <span class="title-fitzmas gold-text">FitzMas</span>
            <span class="title-sub gold-text">Photobooth</span>
        </div>
        <button class="btn-gold" onclick="enterApp()">START</button>
    </div>

    <!-- 3. MAIN PHOTOBOOTH UI -->
    <div id="app-container">
        <!-- Title Overlay (White) -->
        <div id="app-title-overlay">
            <span class="title-fitzmas white-text">FitzMas</span>
            <span class="title-sub white-text">Photobooth</span>
        </div>

        <div id="scene-container">
            <video id="input_video" style="display:none" playsinline muted></video>
            <canvas id="output_canvas"></canvas>
            <div id="sticker-layer"></div>
        </div>
        
        <div id="flash"></div>
        <div id="countdown">3</div>
        <div id="debug-hotspot" onclick="toggleDebugVisibility()"></div>

        <div id="ui-layer">
            <button id="shutter-btn" onclick="startCountdown()"></button>

            <!-- DEBUG CONTROLS -->
            <div id="controls">
                <div class="control-header">
                    <span style="font-weight:bold; color:#00ff88; font-size:14px; font-family:system-ui;">Designer Mode</span>
                    <div style="display:flex; gap:5px;">
                        <button class="debug-btn" onclick="toggleDebug()">Debug</button>
                        <button class="debug-btn" onclick="toggleUI()" id="btn-min">_</button>
                    </div>
                </div>
                <div class="control-content">
                    <hr style="border-color: rgba(255,255,255,0.1); margin: 5px 0 10px 0;">
                    <div id="prop-controls" style="opacity: 0.5; pointer-events: none;">
                        <div class="control-row">
                            <div style="font-size: 11px; color:#fff; font-family:system-ui;"><span id="edit-name">None</span></div>
                            <div class="part-nav" id="part-nav" style="display:none">
                                <button class="debug-btn" onclick="changePart(-1)">&lt;</button>
                                <span id="part-label" style="font-size:10px; font-family:system-ui;">1/1</span>
                                <button class="debug-btn" onclick="changePart(1)">&gt;</button>
                            </div>
                        </div>
                        <div class="control-row"><label>Scale <span id="val-scale">1.0</span></label><input type="range" min="0.1" max="5.0" step="0.1" id="in-scale" oninput="updateProp('scale', this.value)"></div>
                        <div class="control-row"><label>Off X <span id="val-offsetX">0</span></label><input type="range" min="-1000" max="1000" step="5" id="in-offsetX" oninput="updateProp('offsetX', this.value)"></div>
                        <div class="control-row"><label>Off Y <span id="val-offsetY">0</span></label><input type="range" min="-1000" max="1000" step="5" id="in-offsetY" oninput="updateProp('offsetY', this.value)"></div>
                        <div class="control-row"><label>Off Z <span id="val-offsetZ">0</span></label><input type="range" min="-200" max="200" step="5" id="in-offsetZ" oninput="updateProp('offsetZ', this.value)"></div>
                        <hr style="border-color: rgba(255,255,255,0.1); margin: 8px 0;">
                        <div class="control-row"><label>Pitch <span id="val-rotationX">0</span>°</label><input type="range" min="-180" max="180" step="5" id="in-rotationX" oninput="updateProp('rotationX', this.value)"></div>
                        <div class="control-row"><label>Yaw <span id="val-rotationY">0</span>°</label><input type="range" min="-180" max="180" step="5" id="in-rotationY" oninput="updateProp('rotationY', this.value)"></div>
                        <div class="control-row"><label>Roll <span id="val-rotation">0</span>°</label><input type="range" min="-180" max="180" step="5" id="in-rotation" oninput="updateProp('rotation', this.value)"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Result Modal -->
        <div id="result-modal">
            <img id="result-img" src="" alt="Captured Photo">
            
            <div class="modal-btns">
                <!-- NEW (Gold Outline) -->
                <button class="btn-gold-outline" onclick="closeModal()">New</button>
                <!-- DOWNLOAD (Solid Gold) -->
                <a id="download-link" download="photobooth_snap.jpg">
                    <button class="btn-gold">Download</button>
                </a>
            </div>
            <!-- Upload status hidden but present -->
            <div id="cloud-status" style="display:none;"><span id="status-text">Ready</span></div>
        </div>
    </div>

    <!-- UI LOADING OVERLAY -->
    <div id="loading" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 1000;">
        <div class="spinner" style="border: 4px solid #f3f3f3; border-top: 4px solid #00ff88; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto 10px;"></div>
        <div id="loading-text">Starting Camera...</div>
    </div>

    <!-- SHADERS FOR WEBGL -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() { gl_Position = vec4(a_position, 0.0, 1.0); }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;
        uniform vec2 u_resolution;
        uniform float u_time;
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) { 
            const vec2 C = vec2(1.0/6.0, 1.0/3.0); const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy)); vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz); vec3 l = 1.0 - g; vec3 i1 = min(g.xyz, l.zxy); vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx; vec3 x2 = x0 - i2 + C.yyy; vec3 x3 = x0 - D.yyy;
            i = mod289(i); 
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857; vec3 ns = n_ * D.wyz - D.xzx; vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z); vec4 y_ = floor(j - 7.0 * x_); vec4 x = x_ *ns.x + ns.yyyy; vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y); vec4 b0 = vec4(x.xy, y.xy); vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0)*2.0 + 1.0; vec4 s1 = floor(b1)*2.0 + 1.0; vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy; vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
            vec3 p0 = vec3(a0.xy,h.x); vec3 p1 = vec3(a0.zw,h.y); vec3 p2 = vec3(a1.xy,h.z); vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
        }
        void main() {
            vec2 st = gl_FragCoord.xy / u_resolution.xy; st.x *= u_resolution.x / u_resolution.y;
            vec3 colorBg = vec3(0.05, 0.15, 0.1); vec3 colorCloud = vec3(0.29, 0.05, 0.05); 
            float n = snoise(vec3(st * 1.5, u_time * 0.1));
            float n2 = snoise(vec3(st * 4.0 + vec2(u_time*0.05), u_time * 0.15));
            float mask = smoothstep(-0.2, 0.6, n + n2 * 0.5);
            vec3 finalColor = mix(colorBg, colorCloud, mask);
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            float vignette = 1.0 - length(uv - 0.5) * 0.8;
            finalColor *= vignette;
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <script>
        // --- 1. WEBGL & SNOW ANIMATION ---
        const glCanvas = document.getElementById('glCanvas');
        const gl = glCanvas.getContext('webgl');
        const snowCanvas = document.getElementById('snowCanvas');
        const snowCtx = snowCanvas.getContext('2d');
        const burstCanvas = document.getElementById('burstCanvas');
        const burstCtx = burstCanvas.getContext('2d');
        let program, positionLocation, resolutionLocation, timeLocation, buffer;
        let flakes = [];
        let burstParticles = [];
        let wind = 0;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : null;
        }

        function initWebGL() {
            if (!gl) return;
            const vertexSource = document.getElementById('vertex-shader').text;
            const fragmentSource = document.getElementById('fragment-shader').text;
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) return;
            positionLocation = gl.getAttribLocation(program, "a_position");
            resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            timeLocation = gl.getUniformLocation(program, "u_time");
            buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
        }

        function initSnow() {
            flakes = [];
            for(let i=0; i<70; i++) {
                flakes.push({
                    x: Math.random() * snowCanvas.width,
                    y: Math.random() * snowCanvas.height,
                    radius: Math.random() * 3 + 1,
                    speed: Math.random() * 1 + 0.5,
                    offset: Math.random() * Math.PI * 2
                });
            }
        }

        function createBurst() {
            const centerX = burstCanvas.width / 2;
            const centerY = burstCanvas.height / 2;
            for(let i=0; i<50; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 15 + 5;
                burstParticles.push({
                    x: centerX, y: centerY, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    radius: Math.random() * 5 + 2, alpha: 1.0, decay: Math.random() * 0.02 + 0.01
                });
            }
        }

        function resizeGraphics() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            glCanvas.width = w; glCanvas.height = h;
            snowCanvas.width = w; snowCanvas.height = h;
            burstCanvas.width = w; burstCanvas.height = h;
            if(gl) gl.viewport(0, 0, w, h);
        }

        function updateGraphics(time) {
            // WebGL
            if(gl) {
                gl.useProgram(program);
                gl.enableVertexAttribArray(positionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                gl.uniform2f(resolutionLocation, glCanvas.width, glCanvas.height);
                gl.uniform1f(timeLocation, time * 0.001);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }

            // Snow
            wind = Math.sin(time * 0.0005) * 1.5;
            snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
            snowCtx.fillStyle = "rgba(255, 255, 255, 0.6)";
            snowCtx.beginPath();
            for(let f of flakes) {
                f.y += f.speed; f.x += wind + Math.sin((time * 0.002) + f.offset) * 0.5;
                if (f.y > snowCanvas.height) f.y = -5;
                if (f.x > snowCanvas.width) f.x = 0; if (f.x < 0) f.x = snowCanvas.width;
                snowCtx.moveTo(f.x, f.y); snowCtx.arc(f.x, f.y, f.radius, 0, Math.PI * 2);
            }
            snowCtx.fill();

            // Burst
            burstCtx.clearRect(0, 0, burstCanvas.width, burstCanvas.height);
            if (burstParticles.length > 0) {
                for (let i = burstParticles.length - 1; i >= 0; i--) {
                    let p = burstParticles[i];
                    p.x += p.vx; p.y += p.vy; p.alpha -= p.decay;
                    if (p.alpha <= 0) { burstParticles.splice(i, 1); continue; }
                    burstCtx.beginPath(); burstCtx.fillStyle = "rgba(255,255,255," + p.alpha + ")";
                    burstCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); burstCtx.fill();
                }
            }
            requestAnimationFrame(updateGraphics);
        }

        // --- 2. PHOTOBOOTH LOGIC ---
        
        // Configuration
        const CLOUDINARY_CONFIG = { cloudName: "dh85g5yyh", uploadPreset: "fitzmas-photobooth" };
        const SMOOTHING = 0.2; 
        const REFERENCE_FACE_WIDTH = 300; 

        // Filter Definitions
        const FILTERS = [
            { id: 'marnix', parts: [
                { type: 'image', id: 'bandit_beard', src: 'https://i.imgur.com/1vVKJ91.png', anchorIndex: 152, scale: 1.2, offsetX: 0, offsetY: -150, offsetZ: 5, rotation: 0, rotationX: -20, rotationY: 0, zIndex: 100 },
                { type: 'image', id: 'bandana', src: 'https://i.imgur.com/7mkFOI4.png', anchorIndex: 152, scale: 1.3, offsetX: 0, offsetY: 80, offsetZ: -100, rotation: 0, rotationX: -20, rotationY: 0, zIndex: 90 },
                { type: 'image', id: 'cap', src: 'https://i.imgur.com/E7Loive.png', anchorIndex: 10, scale: 1.4, offsetX: 0, offsetY: -15, offsetZ: 30, rotation: 0, rotationX: 0, rotationY: 0, zIndex: 200 }
            ]},
            { id: 'alex', parts: [
                { type: 'image', id: 'alex_glasses', src: 'https://i.imgur.com/r6svhAm.png', anchorIndex: 168, scale: 1.1, offsetX: 0, offsetY: 35, offsetZ: 20, rotation: 0, rotationX: -15, rotationY: 0, zIndex: 200 },
                { type: 'image', id: 'alex_oil', src: 'https://i.imgur.com/QYEBVU1.png', anchorIndex: 454, scale: 1.8, offsetX: 390, offsetY: -365, offsetZ: 200, rotation: 10, rotationX: -15, rotationY: 0, zIndex: 100 }
            ]},
            { id: 'floortje', parts: [
                { type: 'image', id: 'floortje_wig', src: 'https://i.imgur.com/it2jrUM.png', anchorIndex: 10, scale: 1.9, offsetX: 0, offsetY: 190, offsetZ: -15, rotation: 0, rotationX: -10, rotationY: 0, zIndex: 200 },
                { type: 'image', id: 'floortje_necklace', src: 'https://i.imgur.com/lS9mKOb.png', anchorIndex: 152, scale: 1.0, offsetX: 0, offsetY: 155, offsetZ: -125, rotation: 0, rotationX: 0, rotationY: 0, zIndex: 90 }
            ]},
            { id: 'raf', parts: [
                { type: 'image', id: 'raf_mask', src: 'https://i.imgur.com/dFJxaVq.png', anchorIndex: 168, scale: 2.8, offsetX: 0, offsetY: 10, offsetZ: 30, rotation: 0, rotationX: -10, rotationY: 0, zIndex: 150 }
            ]},
            { id: 'mischa', parts: [
                { type: 'image', id: 'mischa_sweater', src: 'https://i.imgur.com/jpKunad.png', anchorIndex: 152, scale: 3.0, offsetX: 0, offsetY: 520, offsetZ: 0, rotation: 0, rotationX: 0, rotationY: 0, zIndex: 50 }
            ]},
            { id: 'derk', parts: [
                { type: 'image', id: 'derk_head', src: 'https://i.imgur.com/3rAuZew.png', anchorIndex: 10, scale: 1.1, offsetX: 0, offsetY: 45, offsetZ: 20, rotation: 0, rotationX: -10, rotationY: 0, zIndex: 200 }
            ]},
            { id: 'jur', parts: [
                { type: 'image', id: 'jur_tall', src: 'https://i.imgur.com/4Vs89Aj.png', anchorIndex: 1, scale: 4.5, offsetX: 0, offsetY: 50, offsetZ: 50, rotation: 0, rotationX: -15, rotationY: 0, zIndex: 200 }
            ]}
        ];

        // State
        let debugMode = false, selectedFaceIndex = -1, selectedPartIndex = 0;
        let faceAssignments = new Map(), detectedFaces = [], faceStates = [], activeFaceData = [], loadedImages = {};
        
        // Elements - Declarations
        let videoElement, canvasElement, stickerLayer, ctx, loadingDiv;
        
        // Landing Page Logic
        function enterApp() {
            document.getElementById('landing-page').style.opacity = 0;
            setTimeout(() => { 
                document.getElementById('landing-page').style.display = 'none'; 
                document.getElementById('app-container').style.display = 'block';
                startCamera();
            }, 500);
        }

        // Vector Math & Rendering
        const f = (n) => n.toFixed(4);
        function subtract(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z }; }
        function cross(a, b) { return { x: a.y * b.z - a.z * b.y, y: a.z * b.x - a.x * b.z, z: a.x * b.y - a.y * b.x }; }
        function normalize(v) { const mag = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z) || 1; return { x: v.x/mag, y: v.y/mag, z: v.z/mag }; }
        
        // SIMPLIFIED MAPPING: Map 0-1 video coords to screen pixels directly (No DPR complexity)
        function getMirroredPoint(l, w, h, offX = 0, offY = 0) { 
            return { 
                x: (1 - l.x) * w + offX, 
                y: l.y * h + offY, 
                z: -l.z * w 
            }; 
        }
        
        function lerp(s, e, a) { return (1 - a) * s + a * e; }
        function lerpVector(v1, v2, a) { return { x: lerp(v1.x, v2.x, a), y: lerp(v1.y, v2.y, a), z: lerp(v1.z, v2.z, a) }; }

        function calculateFaceMatrix(landmarks, width, height, offX, offY) {
            const eyeL = getMirroredPoint(landmarks[33], width, height, offX, offY);
            const eyeR = getMirroredPoint(landmarks[263], width, height, offX, offY);
            const mouth = getMirroredPoint(landmarks[13], width, height, offX, offY);
            const vecX = normalize(subtract(eyeL, eyeR));
            const midEye = { x: (eyeL.x + eyeR.x)/2, y: (eyeL.y + eyeR.y)/2, z: (eyeL.z + eyeR.z)/2 };
            const vecY_raw = normalize(subtract(mouth, midEye));
            const vecZ = normalize(cross(vecX, vecY_raw));
            const vecY = normalize(cross(vecZ, vecX));
            return { x: vecX, y: vecY, z: vecZ };
        }

        function getStickerElement(faceId, partId, src, type, zIndex) {
            if (!stickerLayer) return null; 
            const id = `sticker-${faceId}-${partId}`;
            let el = document.getElementById(id);
            if (!el) {
                el = document.createElement(type === 'image' ? 'img' : 'div');
                if(type === 'image') el.src = src; else { el.innerText = src; el.style.fontSize = "50px"; }
                el.id = id; el.className = 'sticker'; el.style.zIndex = zIndex; 
                stickerLayer.appendChild(el);
            }
            if (type === 'image' && el.src !== src) el.src = src;
            return el;
        }

        function onResults(results) {
            if (loadingDiv) loadingDiv.style.display = 'none'; 
            if (!canvasElement) return;

            // 1. Set Canvas to EXACT Window Size (Logical Pixels)
            // This aligns coordinate systems and fixes the "Tiny" issue on Retina
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;

            // 2. Calculate Center Crop (Cover) logic
            const screenW = canvasElement.width;
            const screenH = canvasElement.height;
            const videoW = results.image.width;
            const videoH = results.image.height;

            const ratio = Math.max(screenW / videoW, screenH / videoH);
            const scaledW = videoW * ratio;
            const scaledH = videoH * ratio;
            const offX = (screenW - scaledW) / 2;
            const offY = (screenH - scaledH) / 2;

            // 3. Draw Video Centered & Mirrored
            ctx.save();
            ctx.translate(screenW, 0); // Move origin to right edge
            ctx.scale(-1, 1); // Flip X
            // Draw image in mirrored context
            ctx.drawImage(results.image, offX, offY, scaledW, scaledH);
            ctx.restore();

            detectedFaces = [];
            const currentStickerIds = new Set();
            activeFaceData = [];

            if (results.multiFaceLandmarks) {
                const sorted = results.multiFaceLandmarks.map((l, i) => ({ l, i, x: l[1].x })).sort((a,b) => a.x - b.x);
                if (sorted.length !== faceStates.length) faceStates = new Array(sorted.length).fill(null);

                sorted.forEach((face, idx) => {
                    const landmarks = face.l;
                    if (!faceAssignments.has(idx)) faceAssignments.set(idx, idx % FILTERS.length);
                    const filter = FILTERS[faceAssignments.get(idx)];

                    // Calculate Un-Projected Width to stop shrinking on rotation
                    const targetWidthRaw = Math.abs(landmarks[454].x - landmarks[234].x) * scaledW;
                    
                    // 1. Get raw orientation 
                    const matrixBasis = calculateFaceMatrix(landmarks, scaledW, scaledH, offX, offY);
                    
                    // 2. Extract Yaw
                    const yaw = Math.atan2(-matrixBasis.z.x, matrixBasis.z.z);
                    
                    // 3. Compensate for foreshortening
                    const cosYaw = Math.max(Math.abs(Math.cos(yaw)), 0.2); 
                    const unprojectedWidth = targetWidthRaw / cosYaw;

                    if (!faceStates[idx]) faceStates[idx] = { w: unprojectedWidth, basis: matrixBasis, anchors: {} };
                    const state = faceStates[idx];
                    
                    state.w = lerp(state.w, unprojectedWidth, SMOOTHING);
                    state.basis.x = lerpVector(state.basis.x, matrixBasis.x, SMOOTHING);
                    state.basis.y = lerpVector(state.basis.y, matrixBasis.y, SMOOTHING);
                    state.basis.z = lerpVector(state.basis.z, matrixBasis.z, SMOOTHING);

                    const faceParts = [];
                    filter.parts.forEach((part, partIdx) => {
                        const el = getStickerElement(idx, part.id, part.src || part.content, part.type, part.zIndex);
                        if (!el) return; 
                        
                        currentStickerIds.add(el.id);
                        
                        // Use SCALED dims + OFFSETS for positioning
                        const rawAnchor = getMirroredPoint(landmarks[part.anchorIndex], scaledW, scaledH, offX, offY);
                        
                        if (!state.anchors[part.anchorIndex]) state.anchors[part.anchorIndex] = rawAnchor;
                        const smoothAnchor = state.anchors[part.anchorIndex];
                        smoothAnchor.x = lerp(smoothAnchor.x, rawAnchor.x, SMOOTHING);
                        smoothAnchor.y = lerp(smoothAnchor.y, rawAnchor.y, SMOOTHING);
                        smoothAnchor.z = lerp(smoothAnchor.z, rawAnchor.z, SMOOTHING);

                        // CSS Scale is 1:1 now
                        const cssScale = 1; 
                        
                        const logicalFaceWidth = state.w; 
                        const depthScale = logicalFaceWidth / REFERENCE_FACE_WIDTH;
                        
                        const X = state.basis.x, Y = state.basis.y, Z = state.basis.z;
                        const rotationMatrix = `matrix3d(${f(X.x)},${f(X.y)},${f(X.z)},0,${f(Y.x)},${f(Y.y)},${f(Y.z)},0,${f(Z.x)},${f(Z.y)},${f(Z.z)},0,0,0,0,1)`;
                        
                        el.style.transform = `
                            translate3d(${f(smoothAnchor.x)}px, ${f(smoothAnchor.y)}px, ${f(smoothAnchor.z)}px)
                            ${rotationMatrix}
                            translateZ(${(part.offsetZ||20)*depthScale}px)
                            rotateX(${part.rotationX||0}deg) rotateY(${part.rotationY||0}deg) rotateZ(${part.rotation||0}deg)
                            translate(${(part.offsetX||0)*depthScale}px, ${(part.offsetY||0)*depthScale}px)
                            translate(-50%, -50%)
                        `;
                        const size = state.w * part.scale;
                        el.style.width = `${size}px`; el.style.height = "auto";
                        el.style.filter = (debugMode && selectedFaceIndex===idx && selectedPartIndex===partIdx) ? "drop-shadow(0 0 10px #00ff88) brightness(1.2)" : "none";
                        el.style.display = 'block';

                        const simpleRoll = Math.atan2(X.y, X.x) + ((part.rotation||0) * Math.PI/180);
                        faceParts.push({ id: part.id, type: part.type, src: part.src, x: smoothAnchor.x + (part.offsetX||0)*depthScale, y: smoothAnchor.y + (part.offsetY||0)*depthScale, scale: size, rotation: simpleRoll, zIndex: part.zIndex });
                    });
                    activeFaceData.push(faceParts);
                    
                    if(debugMode) drawDebugMarkers(ctx, landmarks, scaledW, scaledH, offX, offY);
                    detectedFaces.push({ id: idx, box: getBoundingBox(landmarks, scaledW, scaledH, offX, offY), filterIndex: faceAssignments.get(idx) });
                });
                
                document.querySelectorAll('.sticker').forEach(el => { if(!currentStickerIds.has(el.id)) el.style.display='none'; });
            }
        }

        // --- CAMERA & INIT ---
        async function startCamera() {
            // Initialize elements here to ensure DOM is ready
            videoElement = document.getElementById('input_video');
            canvasElement = document.getElementById('output_canvas');
            stickerLayer = document.getElementById('sticker-layer');
            ctx = canvasElement ? canvasElement.getContext('2d') : null;
            loadingDiv = document.getElementById('loading');

            try {
                if (typeof FaceMesh === 'undefined') throw new Error("MediaPipe failed to load.");
                const faceMesh = new FaceMesh({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({maxNumFaces: 4, refineLandmarks: true, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
                faceMesh.onResults(onResults);
                await loadAssets();
                
                if (videoElement) {
                    const cam = new Camera(videoElement, {
                        onFrame: async()=>{ await faceMesh.send({image:videoElement}); }, 
                        width: 1280, height: 720 
                    });
                    await cam.start();
                }
            } catch (err) { console.error(err); alert("Camera Error: " + err.message); }
        }

        function loadAssets() {
            const promises = [];
            FILTERS.forEach(f => f.parts.forEach(p => {
                if(p.type==='image'){
                    const img = new Image(); img.crossOrigin="Anonymous"; img.src=p.src;
                    promises.push(new Promise(r => { img.onload=()=>{loadedImages[p.id]=img;r();}; img.onerror=()=>{console.warn("Fail:",p.id);r();}; setTimeout(r,3000); }));
                }
            }));
            return Promise.all(promises);
        }

        // --- SNAPSHOT & UI LOGIC ---
        function startCountdown() {
            document.getElementById('shutter-btn').style.display = 'none';
            const countEl = document.getElementById('countdown');
            countEl.style.display = 'block';
            let count = 3; countEl.innerText = count;
            const timer = setInterval(() => {
                count--;
                if (count > 0) countEl.innerText = count;
                else {
                    clearInterval(timer);
                    countEl.style.display = 'none';
                    triggerFlash();
                    takeSnapshot();
                }
            }, 1000);
        }

        function triggerFlash() {
            const flash = document.getElementById('flash');
            flash.style.opacity = 1; setTimeout(() => { flash.style.opacity = 0; }, 100);
        }

        function takeSnapshot() {
            const snapCanvas = document.createElement('canvas');
            snapCanvas.width = canvasElement.width; snapCanvas.height = canvasElement.height;
            const snapCtx = snapCanvas.getContext('2d');
            
            // Draw Video
            snapCtx.drawImage(canvasElement, 0, 0);
            
            // Draw Stickers
            let allParts = []; activeFaceData.forEach(p => allParts = allParts.concat(p));
            allParts.sort((a,b) => a.zIndex - b.zIndex);
            allParts.forEach(p => {
                if(p.type === 'image' && loadedImages[p.id]?.complete) {
                    snapCtx.save();
                    snapCtx.translate(p.x, p.y);
                    snapCtx.rotate(p.rotation);
                    const img = loadedImages[p.id];
                    const aspect = img.height / img.width;
                    const drawW = p.scale; const drawH = p.scale * aspect;
                    snapCtx.drawImage(img, -drawW/2, -drawH/2, drawW, drawH);
                    snapCtx.restore();
                }
            });

            const dataURL = snapCanvas.toDataURL('image/jpeg', 0.9);
            document.getElementById('result-img').src = dataURL;
            document.getElementById('download-link').href = dataURL;
            
            // Show Modal and hide Video to reveal background
            document.getElementById('result-modal').style.display = 'flex';
            document.getElementById('scene-container').style.opacity = '0'; // Hide video so background shows
            document.getElementById('app-title-overlay').style.display = 'none'; // Hide Title
            createBurst(); // Festive burst!

            // Auto Upload
            fetch(dataURL).then(res => res.blob()).then(blob => window.autoUploadToCloud(blob));
        }

        function closeModal() {
            document.getElementById('result-modal').style.display = 'none';
            document.getElementById('scene-container').style.opacity = '1'; // Show video again
            document.getElementById('shutter-btn').style.display = 'block';
            document.getElementById('app-title-overlay').style.display = 'block'; // Show Title
        }

        // --- CLOUD ---
        window.autoUploadToCloud = async function(blob) {
            const statusText = document.getElementById('status-text');
            statusText.innerText = "Backing up...";
            try {
                const formData = new FormData();
                formData.append('file', blob);
                formData.append('upload_preset', CLOUDINARY_CONFIG.uploadPreset);
                formData.append('tags', 'fitzmas_party'); 
                const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CONFIG.cloudName}/image/upload`, { method: 'POST', body: formData });
                const data = await res.json();
                if(data.error) throw new Error(data.error.message);
                statusText.innerText = "Backed up ✔️";
                console.log("Saved:", data.secure_url);
            } catch (err) { console.error(err); statusText.innerText = "Backup Failed"; }
        };

        // --- INITIALIZATION ---
        initWebGL();
        resizeGraphics();
        initSnow();
        requestAnimationFrame(updateGraphics);
        window.addEventListener('resize', () => { resizeGraphics(); initSnow(); });

        // Debug Helpers
        function toggleDebug() { debugMode = !debugMode; document.getElementById('btn-debug').classList.toggle('active', debugMode); if(!debugMode) selectedFaceIndex=-1; }
        function toggleDebugVisibility() { const c = document.getElementById('controls'); c.style.display = c.style.display==='block' ? 'none' : 'block'; }
        function toggleUI() { document.getElementById('controls').classList.toggle('minimized'); }
        document.addEventListener('keydown', e => { if(e.key==='d') toggleDebugVisibility(); });
        
        // Tap Handler for Swapping & Debug
        document.addEventListener('click', e => {
            if (e.target.closest('#controls') || e.target.closest('#shutter-btn') || e.target.closest('#result-modal') || e.target.id === 'debug-hotspot') return;
            
            // FIX: Ensure canvasElement exists before using it
            if (!canvasElement) return; 

            const rect = canvasElement.getBoundingClientRect();
            const normX = 1 - ((e.clientX - rect.left) / rect.width);
            const normY = (e.clientY - rect.top) / rect.height;
            detectedFaces.forEach(face => {
                const b = face.box;
                if (normX >= b.minX && normX <= b.maxX && normY >= b.minY && normY <= b.maxY) {
                    if (debugMode) activateControls(face.id);
                    else faceAssignments.set(face.id, (face.filterIndex + 1) % FILTERS.length);
                }
            });
        });

        // Debug UI Updaters
        // UPDATED: Now accepts scaled dims and offsets
        function getBoundingBox(l, w, h, offX, offY) { 
            let minX=1, minY=1, maxX=0, maxY=0; 
            // Loop through all landmarks to find bounding box in 0-1 space (video space)
            // But we need to map to 0-1 Screen Space for click detection
            // Video Space (0-1) -> Screen Pixel Space (via getMirroredPoint logic) -> Screen Normalized (0-1)
            
            // Wait, click detection is normalized 0-1 of the SCREEN.
            // We need to convert landmarks to Screen Pixels first.
            
            let minScreenX = Infinity, minScreenY = Infinity, maxScreenX = -Infinity, maxScreenY = -Infinity;
            
            l.forEach(p => {
                // Same logic as getMirroredPoint for X (Mirror) and Y
                // Note: Click logic expects "Right is Left" due to mirror view? 
                // In getMirroredPoint: x = (1 - l.x) * w + offX.
                // This gives pixel coords.
                const px = (1 - p.x) * w + offX;
                const py = p.y * h + offY;
                
                if(px < minScreenX) minScreenX = px;
                if(px > maxScreenX) maxScreenX = px;
                if(py < minScreenY) minScreenY = py;
                if(py > maxScreenY) maxScreenY = py;
            });
            
            // Convert pixels back to normalized 0-1 relative to canvas size
            const canvasW = canvasElement.width;
            const canvasH = canvasElement.height;
            
            // Note: Click Logic (normX) logic was: 1 - ((e.clientX...) / width).
            // That logic assumes the click X is also "mirrored" relative to screen.
            // If I tap Left side of screen (small clientX), normX is ~1.0.
            // If I tap Right side (large clientX), normX is ~0.0.
            
            // My getMirroredPoint logic puts right-side-of-face (small l.x) at Right Side of Screen (Large Pixel X).
            // So a Large Pixel X should correspond to a Small normX?
            
            // Let's align: 
            // Pixel X = 1000 (Right side). 
            // normX in click handler = 1 - (1000/1280) = 0.2.
            
            // So we need to normalize the pixel bounding box to 0-1, then Flip X?
            // Actually, let's just return the Normalized Screen Coordinates (0-1, Left-to-Right).
            // And fix the click handler to match.
            
            // Bounding Box in standard 0-1 (Left is Left)
            return {
                minX: 1 - (maxScreenX / canvasW), // Flip! Max Pixel X is Left side in mirrored normX?
                maxX: 1 - (minScreenX / canvasW),
                minY: minScreenY / canvasH,
                maxY: maxScreenY / canvasH
            };
        }
        
        function drawDebugMarkers(ctx, l, w, h, offX, offY) { 
            ctx.save(); 
            // We are already in a context that is translated/mirrored for the video draw?
            // No, onResults restores context after drawing video.
            // So we are in standard 0,0 top-left context.
            // But getMirroredPoint returns coordinates for standard 0,0 top-left drawing (it handles the mirror math manually).
            // So we just draw at the points.
            
            [10,168,1,152].forEach(id=>{
                const p = getMirroredPoint(l[id], w, h, offX, offY); 
                // scale coordinates down if drawing on high-dpi canvas via CSS pixels?
                // ctx is high-res. p is high-res.
                ctx.beginPath(); 
                ctx.arc(p.x, p.y, 4, 0, 2*Math.PI); 
                ctx.fillStyle='red'; 
                ctx.fill();
            }); 
            ctx.restore(); 
        }
        
        function activateControls(idx) { selectedFaceIndex=idx; selectedPartIndex=0; document.getElementById('prop-controls').style.opacity='1'; document.getElementById('prop-controls').style.pointerEvents='auto'; refreshControlsUI(); }
        function refreshControlsUI() {
            const f = FILTERS[faceAssignments.get(selectedFaceIndex)], p = f.parts[selectedPartIndex];
            document.getElementById('edit-name').innerText = `${f.id.toUpperCase()} (${p.id})`;
            const nav = document.getElementById('part-nav'); nav.style.display = f.parts.length>1?'flex':'none';
            if(nav.style.display!=='none') document.getElementById('part-label').innerText = `${selectedPartIndex+1}/${f.parts.length}`;
            ['scale','offsetX','offsetY','offsetZ','rotation','rotationX','rotationY'].forEach(k => {
                const val = p[k] !== undefined ? p[k] : (k==='scale'?1:0);
                document.getElementById(`in-${k}`).value = val; document.getElementById(`val-${k}`).innerText = val;
            });
        }
        function updateProp(k, v) { const p = FILTERS[faceAssignments.get(selectedFaceIndex)].parts[selectedPartIndex]; p[k] = parseFloat(v); refreshControlsUI(); }
        function changePart(d) { const f = FILTERS[faceAssignments.get(selectedFaceIndex)]; let n = selectedPartIndex + d; if(n<0) n=f.parts.length-1; if(n>=f.parts.length) n=0; selectedPartIndex=n; refreshControlsUI(); }

    </script>
</body>
</html>
